[ { "title": "D3 Icicle Chart Transition", "url": "/posts/D3-icicle-chart-transition/", "categories": "d3", "tags": "d3, react, transition", "date": "2022-07-28 00:00:00 +0900", "snippet": "icicle chart 다음 목표는 transition을 넣는 것이다. 클릭한 블럭만 transition을 넣는 것이 아니라, 다른 블럭도 함께 움직이는 transition이라 생각하기가 쉽지 않다.Node vs Selectiontransition을 부여하기 위해선, Node와 Selection을 구별할 줄 알아야한다. Node는 hierarchy 함수를 통해 데이터를 갖는 객체이고, Selection은 해당 데이터를 통해 실질적으로 눈에 보여지는 element 들이다. 그렇기 때문에, transition은 Node가 아니라 Selection에 부여할 수 있다.SelectionNodeSelection의 하위 Selection 참조Node는 결국 Tree 자료구조이기 때문에 하위 Node를 참조하는 것이 가능하다. 하지만, Selection은 element 이기 때문에 하위 데이터를 물고 있는 Selection을 참조하는 것이 불가능하다. 실제로 children 이라는 프로퍼티를 참조해도 데이터 상 하위 Selection이 아니라 실제 element 내부의 다른 태그를 반환받게 된다. (svg &gt; g &gt; rect)그러면 어떡하지?githru에서 보여지는 icicle chart transition을 주기 위해선, click event의 target과 해당 Selection의 하위 Selection 들에 transition을 부여해야한다. 하지만, 앞서 언급했듯 그것은 불가능하기 때문에, 차트를 구성하는 모든 Selection에 transition을 부여함으로써 적용할 수 있다.HierarchyRectangularNodeHierarchyRectangularNode는 차트를 구성하는 element의 각 좌표 값을 제공한다. 하지만, HierarchyRectangularNode의 값이 수정된다고 해서 바로 결과가 View에 반영되진 않는다. HierarchyRectangularNode의 데이터를 수정하고, transition과 attr를 통해 View에 반영하는 작업을 거쳐야 비로소 View의 변화가 일어난다.가장 중요한 건 좌표 수정 !이번 transition을 적용하는 데 있어서 가장 중요한 건 결국 좌표 값 계산이다. zoom-in 시 결정되는 결과의 좌표값을 계산해서 transition만 적용시켜주면 되기 때문이다.좌표 수정 시 주의할 점아래 코드와 같이 좌표를 수정했더니, 문제가 발생했다. target은 event target이다. target이 수정되면, target 이후에 작업이 실행되는 Node들은 target의 수정된 값을 참조하는 것이다. 예상했던 결과값을 얻지 못했다.cell.each((d) =&gt; { d.x0 = d.x0 - target.x0; d.x1 = d.x1 - target.x0 + height; d.y0 = d.y0 - target.y0; d.y1 = 2;});아래와 같이 미리 target 값을 복사한 후 작업하니 제대로 동작했다.const { x0, x1, y0, y1 } = target;cell.each((d) =&gt; { d.x0 = d.x0 - x0; d.x1 = d.x1 - x0 + height; d.y0 = d.y0 - y0; d.y1 = 2;});width transition위에서 언급했듯, width transition에 관여하는 좌표 값은 y0, y1 이다. 적절한 계산을 통해 y0, y1을 정해주어야 한다. 기존에 y0, y1을 관리하던 방식은 왼쪽부터 height수에 전체 width를 곱한 수를 사용하고 있었다. (ex 0, 500, 1000, 1500 …) 이후에 실제 width를 정해줄 때 해당 값에 실제 비율을 적용하여 화면에 보여주는 방식이었다. 그러므로 click target의 y0와 비교하여 얼마나 차이가 있는지만 계산해주면 된다. 아래는 각 Node의 y0 값을 target의 y0와의 차로 대입하는 식이다.d.y0 = d.y0 - y0;height transitionheight 에 관여하는 좌표는 x0, x1 이다. 적절한 x0, x1을 계산하여 transform y, height를 구해보자. 아래 icicle chart 에서 src/2 rect를 클릭한다고 가정하자. 그러면, src/2 transition/transition.js util/options.js 3개의 rect가 svg를 꽉 채울 것이다.편의를 위해 src/2 를 1번 블록, transition/transition.js 를 2번 블록, util/options.js 를 3번 블록이라하자.1번 블록의 높이는 transition 이후 svg의 height 만큼 증가한다. 이 비율을 기억해두자 (transition 이전 1번 블록의 높이 : svg 높이)3번 블록의 x0 - 1번 블록의 x0 값이 transition 이후에 변경되는 값과의 비율은 앞의 비율과 같다.정리하자면,transition 이전 1번 블록의 높이 : svg 높이 = block3's x0 - block1's x0 : transition 이후 3번 블록의 x0 =&gt; d.x0 이고,target.x1 - target.x0 : height = d.x0(이전) - target.x0 : d.x0(이후) ,d.x0(이후) = (d.x0(이전) - target.x0) * height / target.x1 - target.x0 이라는 결과가 도출된다.d.x0 = (d.x0 - x0) * (height / (x1 - x0));다음은 x1 을 구할 차례다. x0 을 구할 때와 동일하게 1번 블록의 transition 이전과 이후 비율과 비교하여 구할 수 있다.transition 이전 1번 블록의 높이 : svg 높이 = block2's x1 - block1's x0 : transition 이후 2번 블록의 x1 =&gt; d.x1 ,target.x1 - target.x0 : height = d.x1(이전) - target.x0 : d.x1(이후) ,d.x1(이후) = (d.x1(이전) - target.x0) * height / target.x1 - target.x0d.x1 = (d.x1 - x0) * (height / (x1 - x0));반영하기위치 정보를 나타내는 translate는 아래와 같다. target.height+1에 따라서 svg의 width가 몇 개로 나눠지는 지 정해지기 때문에, svg의 width 단위로 정해두었던 y0의 값을 구해줄 수 있다." }, { "title": "React Native Splash Screen", "url": "/posts/React-Native-SplashScreen/", "categories": "React Native", "tags": "ReactNative, SplashScreen", "date": "2022-07-25 00:00:00 +0900", "snippet": "앱을 시작하기 전에 화면에 등장하는 스플래시 이미지를 React Native 환경에서 적용해보자. react-native-splash-screen 라이브러리를 활용하여 구현할 수 있다. iOS에서 실행을 확인할 수 있는 방법이 없어, 안드로이드 환경에서 구현하는 방법만 살펴본다.Installingreact-native-splash-screen을 설치한다.yarn add react-native-splash-screenAndroid아래 순서로 프로젝트 내부 빌드 파일들을 수정한다.settings.gradleinclude ':react-native-splash-screen'project(':react-native-splash-screen').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-splash-screen/android')android/app/build.gradlecompile-time dependency를 추가한다....dependencies { ... implementation project(':react-native-splash-screen')}MainApplication.java패키지를 추가해준다. 아래와 같이 SplashScreenReactPackage 를 추가하는데, 패키지가 이미 존재한다는 문제가 발생하면 getPackages 함수 내부의 수정 내용을 없앤다. import 만 해주면 자동으로 패키지를 추가해주기 때문에 중복 문제가 발생한다.// react-native-splash-screen &gt;= 0.3.1import org.devio.rn.splashscreen.SplashScreenReactPackage;// react-native-splash-screen &lt; 0.3.1import com.cboy.rn.splashscreen.SplashScreenReactPackage;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { @Override public boolean getUseDeveloperSupport() { return BuildConfig.DEBUG; } @Override protected List&lt;ReactPackage&gt; getPackages() { return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new SplashScreenReactPackage() //here ); } }; @Override public ReactNativeHost getReactNativeHost() { return mReactNativeHost; }}MainActivity.javaMainActivity의 onCreate 함수 내부에 SplashScreen.show(this); 라인을 추가하여 스플래시 화면이 출력되도록 한다.import android.os.Bundle; // hereimport com.facebook.react.ReactActivity;// react-native-splash-screen &gt;= 0.3.1import org.devio.rn.splashscreen.SplashScreen; // here// react-native-splash-screen &lt; 0.3.1import com.cboy.rn.splashscreen.SplashScreen; // herepublic class MainActivity extends ReactActivity { @Override protected void onCreate(Bundle savedInstanceState) { SplashScreen.show(this); // here super.onCreate(savedInstanceState); } // ...other code}app/src/main/res/layout/launch_screen.xmllayout 폴더가 없으면, layout 폴더를 생성하여 추가한 후 아래와 같은 xml 파일을 작성한다. 가장 중요한 부분은, android:src=\"@drawable/launch_screen\" 이곳인데, 이미지의 확장자명을 제외한 파일 이름을 @drawable/ 뒤에 입력해야한다.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:src=\"@drawable/launch_screen\" android:scaleType=\"centerCrop\" /&gt;&lt;/RelativeLayout&gt;drawble이후 res/drawable/ 디렉토리 내부에 launch_screen.png 와 같은 이미지를 복사한다.App.tsxsplash 이미지를 숨길 타이밍을 정한다.useEffect(() =&gt; { setTimeout(() =&gt; { SplashScreen.hide(); }, 1000); }, []);" }, { "title": "TCP vs UDP", "url": "/posts/TCPvsUDP/", "categories": "network", "tags": "network, TCP, UDP", "date": "2022-07-08 00:00:00 +0900", "snippet": "TCP란4계층 transport layer에서 작동하는 통신 프로토콜로써, 연결 지향적 프로토콜이다. 연결 지향적 프로토콜이라는 말은 미리 연결을 맺어 두고 해당 연결을 통해 신뢰성 있는 통신을 하는 것이다.특징신뢰성 : 손상되거나 유실 혹은 중복된 패킷에 대한 처리가 이루어져 수신자로 하여금 송신자가 보낸 패킷을 제대로 받을 수 있도록 보장함.흐름 제어 : TCP Segment를 수신 혹은 송신하는 컴퓨터는 CPU와 네트워크 간 대역폭 차이 때문에 서로 다른 속도로 작동할 수 있다. 이는 송신자와 수신자 간 속도가 맞지 않게 될 수 있다는 것인데, TCP는 이러한 흐름 제어 또한 처리할 수 있다.다중화 : 여러 프로세스가 TCP 통신을 동시에 사용할 수 있다. 각 프로세스는 4계층에서 포트 번호로써 식별할 수 있기 때문.3 way handshake : TCP는 연결을 맺기 위해 3 way handshake 협상을 이용하여 연결을 맺는다. 요청하는 쪽이 SYN을 보내면, 요청 받는 쪽이 SYN+ACK 세그먼트를 보내고, 이후 요청을 시작한 쪽이 SYN+ACK을 받게 되면 다시 요청 받는 쪽에게 ACK를 보내어 연결을 성립하게 한다.그림 출처 : https://velog.io/@jjewqm/TCP-3-Way-HandShaking4 way handshake : 연결을 끊기 위한 협상 방식이다. 연결 종료를 요청하는 쪽이 FIN을 보내면 ACK를, ACK를 받으면 FIN을 보내어 다시 ACK를 보낸다. 연결을 맺을 때는 3 way handshake지만 끊을 때는 4 way handshake를 사용하는 이유는, 한 쪽이 송수신 작업이 끝났다고 해서 다른 쪽 작업도 모두 끝났을 것이라는 보장이 없기 때문이다.그림 출처 : https://velog.io/@jjewqm/TCP-3-Way-HandShakingUDP란패킷이 서로 독립적인 비연결형 프로토콜이다. 연결을 맺지 않고 사용하기 때문에 연결에 걸리는 시간이 필요 없고 전송하는데 속도가 빠르다. 그렇기 때문에 주로 게임처럼 응답성이 좋아야 하는 곳에 널리 쓰인다.특징비연결형 : 별도의 연결 작업을 거치지 않고 데이터를 송수신한다.신뢰성x : TCP는 패킷끼리의 정보를 서로 공유하고 세그먼트의 순서나 여러 정보를 갖고 있기 때문에 유실된 패킷을 찾아내고 중복된 패킷을 거를 수 있는데, 앞서 설명한 것과 같이 UDP는 패킷끼리 서로 독립적으로 작동하기 때문에 신뢰성을 보장할 수 없다.응답성 : TCP 같은 경우, 패킷의 유실이 일어나면 해당 패킷을 재전송 하기 위해 작업을 수행하게 되는데, 온라인 게임과 같이 실시간성이 중요한 부분에서는 매우 비효율적일 수 있다. 하지만, UDP 같은 경우 이러한 패킷 유실이나 중복에 대해 처리하지 않고 넘어가기 때문에 높은 응답성을 보장할 수 있다. 또한 TCP와 같이 하나 보낼 때마다 ACK를 보내어 처리하지 않고 데이터만 전달하기 때문에 응답성이 좋게된다.그림 출처 : https://www.reddit.com/r/ProgrammerHumor/comments/9gcwgw/tcp_vs_udp/TCP의 흐름 제어TCP는 UDP와 다르게 데이터만 무조건 보내지 않고 컴퓨터와 네트워크간 속도를 조절하며 송수신을 진행한다. 그렇다면 TCP는 어떻게 흐름 제어가 가능하도록 할까 Stop and Wait미션을 구현한 것과 같이, 수신 측의 ACK를 받아야 다음 데이터를 보낼 수 있도록 처리한다. 하지만, 이렇게 처리하면 데이터를 보낸 이후 다음 데이터를 보낼 수 있음에도 불구하고 무조건 기다려야 하기 때문에 지연이 발생한다. Sliding Window위 문제를 해결하기 위해 Sliding Window라고 하는 해결 방법이 있다. Window size를 정해서 window size만큼 패킷을 보낸 뒤, 수신이 완료되어 ACK를 전달 받으면 window를 서서히 옆으로 밀며 다음 데이터를 연속적으로 송신하는 기법이다.그림 출처 : https://m.blog.naver.com/gaegurijump/110188012832⇒ 순서대로 데이터를 보내고 수신이 확인되면, 다음 받아야 할 패킷의 번호를 ACK와 함께 전달한다. 이후 송신자는 수신이 확인 된 패킷만큼 window를 sliding 시켜 보낼 수 있는 데이터를 늘려 나간다.⇒ 패킷의 유실이 일어나면 ACK를 전송 받지 못하게 되고 일정 시간이 지나면 해당 패킷을 재전송 하게 된다.TCP의 혼잡 제어각 라우터에 패킷이 몰리는 것을 방지하기 위해 TCP는 window size를 증가시키고 또 감소시킴을 통해 혼잡 제어 또한 지원한다. AIMD(Additive Increase/Multiplicative Decrease)이름 그대로 window size를 증가시킬 때는 linear하게 증가시키지만, 감소시킬 때는 exponential하게 줄임. 예를 들어서 라우터가 혼잡하지 않으면 1씩 계속 size를 증가시키다가, 혼잡이 발생했다고 감지하면 size를 반으로 줄여버린다.그림 출처: https://evan-moon.github.io/2019/11/26/tcp-congestion-control/ slow startAIMD를 이용하면 아래 그림과 같이 빨간색 빗금 부분 만큼의 패킷을 보낼 수 없으므로 비효율적이다. 그렇기 때문에 slow start를 적용하는데, 이름이 slow start인 이유는 증가량이 고정된 것이 아니라 처음에는 천천히 증가하다가 시간이 흐를수록 급격하게 window size를 증가 시킨다. 아래 두 번째 그림을 참조하자 !⇒ 더 빨리 최대치에 도달할 수 있기 때문에 효율적이다." }, { "title": "Promise.all", "url": "/posts/Promise-all/", "categories": "JavaScript", "tags": "JavaScript, promise, async", "date": "2022-07-06 00:00:00 +0900", "snippet": "자바스크립트에서 비동기 작업을 처리하는 방법으로는 분류하자면 세 가지가 존재한다. 첫 번째는 콜백함수를 호출하는 것이고, 두 번째는 Promise.then, 마지막은 문법적으로 처리할 수 있는 async await 키워드를 이용한 방법이다.사실, async await 키워드를 가지고 비동기 작업을 처리하면 매우 간단하다. Promise를 반환하는 작업 앞에 await를 붙이고 해당 함수를 async function으로 만들어주면 되기 때문이다.하지만, 아래와 같은 코드에서처럼 async await를 사용하게 되면 비효율적인 문제가 발생한다.Problema는 1초 후 1을 반환하는 비동기 함수이고, b는 2초 후 2를, c는 3초 후 3을 반환하는 비동기 함수이다. 비동기 처리를 위해 main 에서는 async await 키워드를 통해 a, b, c 함수의 실행 순서를 보장한다. 그렇기 때문에 총 실행 시간은 1000 + 2000 + 3000 = 6000ms 가 된다. a, b, c 는 서로를 필요로하지 않는 독립적인 값인데도 불구하고 앞의 결과를 기다려야 한다는 문제가 있다.const a = () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000); });};const b = () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2); }, 2000); });};const c = () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(3); }, 3000); });};const main = async () =&gt; { const start = new Date(); const _a = await a(); const _b = await b(); const _c = await c(); console.log(_a); console.log(_b); console.log(_c); const end = new Date(); console.log(end - start);};main();Solution위와 같은 문제를 해결하려면 Promise.all 함수를 이용해야 한다. 해당 함수는 여러 개의 비동기 작업을 병렬적으로 (block 없이 한 번에 요청) 처리하기 때문에 async await를 통해 block 하는 것보다 더 빨리 결과 값을 얻을 수 있다.const main = async () =&gt; { const start = new Date(); const [_a, _b, _c] = await Promise.all([a(), b(), c()]); console.log(_a); console.log(_b); console.log(_c); const end = new Date(); console.log(end - start);};Polyfill그렇다면, Promise.all 함수는 어떻게 구현되어 있을까? 궁금했기 때문에 직접 구현해보기러 한다. 참고로 아래 코드는 공식적인 코드가 아니라 필자의 머릿속에서 나온 아주아주 간단한 코드인 것을 감안했으면 좋겠다.const all = (promises) =&gt; { return new Promise((resolve, reject) =&gt; { const results = Array.from({ length: promises.length }).map(() =&gt; null); let count = 0; promises.forEach((promise, i) =&gt; { promise.then((result) =&gt; { results[i] = result; if (++count &gt;= promises.length) resolve(results); }); }); });};우선 all 함수의 인자로 promise의 배열을 전달 받았다. 그리고, 배열 내에 같은 인덱스에 결과 값이 전달이 되어야 하기 때문에, 인자로 전달 받은 배열과 같은 크기의 result 배열을 선언해준다.그리고, 모든 작업이 끝나면 results 배열을 resolve 해주기 위해, count 변수를 하나 둔다. 하나의 promise가 resolve 될 때마다 결과 값을 results 배열의 같은 인덱스에 넣어주고 count 를 1 증가시킨다.만약, count 값이 인자로 전달 받은 배열의 크기보다 크거나 같아지면, results 배열을 resolve 한다.Resultasync/awaitall" }, { "title": "ESLint", "url": "/posts/ESLint/", "categories": "JavaScript", "tags": "ESLint", "date": "2022-07-04 00:00:00 +0900", "snippet": "ESLint 란?ES + Lint 로써 ES는 Ecma Script 즉, 표준 JavaScript를 의미하고 Lint는 직역하면 보푸라기라는 뜻인데, 코드에서 보푸라기란 오류, 버그, 스타일 오류, 의심스러운 구조체 등이라고 한다.따라서 ESLint는 JavaScript를 개발하는데 있어서 Type error나 import error 등을 잡아줄 수 있고, 더 나아가 협업하는데 있어서 미리 코드 스타일을 지정해두고 해당 스타일에 맞게 사용하지 않으면 오류를 띄워 맞춰주는 역할을 수행한다.예를 들어, 아래와 같은 상황을 보자. John이 짠 코드import React from \"react\";import MainPage from \"./page/main\"; Tom이 짠 코드import MainPage from \"./page/main\";import React from \"react\";두 코드는 같은 모듈 두 가지를 import 했지만, 순서도 서로 다르고 string 시 John은 single quote, Tom은 double quote를 사용했다. 만약 이 둘이 같은 프로젝트를 진행했고 이런 식으로 다른 스타일의 코드를 작성한다면, 일관성 없는 코드가 될 것이다. 또한, github과 같은 형상 관리 시스템에 올라갈 때도, 위의 예시로 보면 모듈을 추가하거나 삭제한 내용이 아니어도 import order의 변경, quote 개수의 변경으로 인해 diff가 찍힐 것이고, 이는 코드 리뷰를 하는 입장에서도 어지러울 것이다.본 프로젝트에서는 이러한 문제들을 막기 위해 ESLint를 적용했고, 전체적인 스타일은 airbnb를 따르기로 한다.ESLint 시작하기eslint는 프로젝트의 root에 eslint config 파일을 통해 적용된다. 주로 js, json 파일로써 관리된다.lint config는 크게 extends, plugin, rule을 확인할 수 있다. 본 프로젝트에 적용된 lint 설정을 확인하며 알아보자.plugin\"plugins\": [\"react\", \"@typescript-eslint\", \"react-hooks\"], ESLint는 서드파티 플러그인 사용을 지원한다. 플러그인 패키지를 설치하고, 해당 플러그인을 plugins에 추가하여 사용할 수 있다.extends\"extends\": [ \"airbnb\", \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\", \"plugin:import/typescript\", \"plugin:import/recommended\"], extends 는 추가한 플러그인에서 사용할 규칙을 설정한다. 플러그인은 일련의 규칙 집합이며, 플러그인을 추가하여도 규칙은 적용되지 않는다. 규칙을 적용하기 위해서는 추가한 플러그인 중, 사용할 규칙을 추가해주어야 적용이 된다.rules\"rules\": { \"no-shadow\": \"off\", \"@typescript-eslint/no-shadow\": [\"error\"], \"react-hooks/rules-of-hooks\": \"error\", \"react-hooks/exhaustive-deps\": \"warn\", \"react/jsx-filename-extension\": [1, { \"extensions\": [\".tsx\", \".js\", \".jsx\"] }], \"react/function-component-definition\": [ \"warn\", { \"namedComponents\": \"arrow-function\", \"unnamedComponents\": \"arrow-function\" } ], \"import/extensions\": [ \"error\", \"ignorePackages\", { \"ts\": \"never\", \"tsx\": \"never\" } ], \"import/order\": [ \"error\", { \"groups\": [\"builtin\", \"external\", [\"parent\", \"sibling\"], \"index\"], \"pathGroups\": [ { \"pattern\": \"react\", \"group\": \"external\", \"position\": \"before\" }, { \"pattern\": \"~**\", \"group\": \"external\", \"position\": \"after\" } ], \"pathGroupsExcludedImportTypes\": [\"react\"], \"alphabetize\": { \"order\": \"asc\", \"caseInsensitive\": true }, \"newlines-between\": \"always\" } ] } extends에서 추가한 플러그인을 통해 구체적인 규칙을 정해준다. 글의 처음에 언급했던 import order 규칙을 적용한 모습을 확인할 수 있다. off : 규칙을 사용하지 않음. warn : 규칙을 어기면 warning 발생 error : 규칙을 어기면 error 발생ESLint 적용하기글의 마지막에 나온 블로그를 참조하여 본 프로젝트의 eslint 설정을 진행했다. airbnb 스타일을 적용하니, function component를 작성할 때 function expression으로 바꿔주는 것이 마음에 들지 않아 arrow function으로 작성할 수 있도록 rule을 변경 해보았다. 그럼 시작 해보자 !Step 1: 리액트 프로젝트 생성 (with Typescript)npx create-react-app my-app --template typescript**Step 2: 기존 설정 삭제 (더 나은 설정을 위해)**\"eslintConfig\": { \"extends\":[ \"react-app\", \"react-app/jest\" ]}**Step 3: ESLint package 설치**npm install eslint --save-dev→ 실행 후 package.json 파일에 dependency가 추가된 것을 확인할 수 있음.\"devDependencies\": { \"eslint\":\"^7.20.0\"}Step 4: ESLint 설정npx eslint --init How would you like to use ESLint?Select: To check syntax, find problems, and enforce code style What type of modules does your project use?Select: JavaScript modules (import/export) Which framework does your project use?Select: React Does your project use TypeScript?Select: Yes Where does your code run?Select: Browser How would you like to define a style for your project?Select: Use a popular style guide Which style guide do you want to follow?Select: Airbnb: https://github.com/airbnb/javascript What format do you want your config file to be in?Select: JSON→ 결과로, package.json에 dependency 생성됨.\"devDependencies\": {\t\"@typescript-eslint/eslint-plugin\": \"^4.15.1\",\t\"@typescript-eslint/parser\": \"^4.15.1\",\t\"eslint\": \"^7.20.0\",\t\"eslint-config-airbnb\": \"^18.2.1\",\t\"eslint-plugin-import\": \"^2.22.1\",\t\"eslint-plugin-jsx-a11y\": \"^6.4.1\",\t\"eslint-plugin-react\": \"^7.22.0\",\t\"eslint-plugin-react-hooks\": \"^4.2.0\"}**Step 5: Running ESLint**npx eslint &lt;targetFile&gt; # 오류 확인하기ornpx eslint &lt;targetFile&gt; --fix # 오류 자동 수정ornpx eslint &lt;targetFile&gt; --quiet # 경고 무시하기**Step 5.1: Let’s Run!**npx eslint src/*npx eslint src/* --fixError 처리**Problem: “‘no-use-before-define”**\"rules\": {\t\"no-use-before-define\": \"off\",\t\"@typescript-eslint/no-use-before-define\": [\"error\"]}→ eslintrc.json 추가**Problem: “‘react/jsx-filename-extension”**\"rules\":{\t…\t\"react/jsx-filename-extension\": [ \"warn\", {\"extensions\": [\".tsx\"]} ]}→ eslintrc.json 추가**Problem: “import/no-unresolved”**yarn add -D eslint-import-resolver-typescript\"settings\": {\t\"import/resolver\": {\t\"typescript\": {}\t}}→ eslintrc.json 추가**Problem: “import/extensions”**\"rules\":{\t…\t\"import/extensions\": [\t\t\"error\",\t\t\"ignorePackages\",\t\t{\t\t\"ts\": \"never\",\t\t\"tsx\": \"never\"\t\t}\t]}→ eslintrc.json 추가**Problem: “no-undef”**\"extends\": [\t…\t\"plugin:@typescript-eslint/recommended\"],→ eslintrc.json 추가**Problem: “no-shadow”**\"rules\":{\t…\t\"no-shadow\": \"off\",\t\"@typescript-eslint/no-shadow\": [\"error\"]}**Problem: Any error over files that are not ‘js’,’jsx’, ‘ts’, or ‘tsx’ extension files***.css*.svg→ .eslintignore에 추가Problem: react/function-component-definition\"react/function-component-definition\": [ \"warn\", { \"namedComponents\": \"arrow-function\", \"unnamedComponents\": \"arrow-function\" }]→ eslint rule에 추가출처Setting ESLint on a React Typescript project 2021" }, { "title": "JavaScript's this", "url": "/posts/JavaScript-this/", "categories": "JavaScript", "tags": "JavaScript, this", "date": "2022-07-03 00:00:00 +0900", "snippet": "js로 프로그래밍 할 때, this를 사용함에 있어서 큰 혼란을 겪었다. 같은 객체 안에서 this 키워드를 통해 내부의 메서드를 호출하거나 프로퍼티를 사용하려고 할 때, 의도한 대로 this가 결정되지 않아 어려움을 겪었고 이에 따라 필자는 this가 결정되는 원리부터 상황에 따른 this의 결정에 대해 정리하고자 한다.JavaScript의 this는 함수 호출 시 함수가 어떻게 호출 되었는지 즉 함수 호출 패턴에 따라 값이 결정된다. 함수 호출 패턴은 여러가지 상황이 있을 수 있기 때문에 각 상황 별로 this가 어디에 바인딩 되는지 알아보고, 어떻게 해결 해야 하는지 살펴보자.자바의 this vs 자바스크립트의 this Java자바에서의 this는 객체 자신의 참조 값을 갖는다. 아래 예시를 보자.public class Person { private String name; public Person(name) { \tthis.name = name; }}자바에서 this는 Person으로 생성된 객체를 가리키기 때문에 주로 생성자에서 필드 변수와 파라미터를 구분하기 위해 쓰였다. JavaScript자바스크립트의 경우 this는 자바와 달리 실행 시간에 결정되는데, 이로 인해 자바에서 든 예시의 Person 클래스로 생성된 객체 내부에서 작성한 this 키워드라도 Person 객체를 가리키지 않는 상황이 일어날 수 있다.this가 결정되는 내부 구조 실행 컨텍스트 (Execution Context)자바스크립트의 핵심 원리인 실행 컨텍스트 내부에서 this의 정보를 담고 있다. 함수를 호출할 때 하나의 실행 컨텍스트가 만들어져 스택에 쌓이게 된다. 실행 컨텍스트에는 변수와 함수를 담고 있는 객체를 가리키고 있는 Variable Object와 상위 스코프의 정보를 담고 있는 Scope Chain, 그리고 this의 정보를 담고 있다. 함수 호출 시 실행 컨텍스트의 생성 과정순서는 아래와 같고, 함수가 호출되어 하나의 실행 컨텍스트가 스택에 쌓이게 될 때 this가 한 번 결정되는 구조이다. 스코프 체인 연결 VO 연결 함수 실행 패턴에 따른 this 결정 함수 실행 패턴this는 함수가 호출됐을 때마다 스택에 실행 컨텍스트가 쌓이고, 실행 컨텍스트마다 this가 결정되기 때문에 함수 호출 패턴에 따라 어디에 this가 바인딩 될지 결정된다. 그렇다면, 함수 호출 패턴에는 어떤 것이 있을까? 함수 호출 패턴은 아래와 같이 크게 4가지로 나뉜다고 한다. 함수 호출 메소드 호출 생성자 함수 호출 apply/call/bind 호출 함수 호출기본적인 함수의 호출은 전역 객체를 가리키고 있다. 여기서 전역 객체란, 프로그램이 실행된 후 가장 먼저 EC 스택에 쌓이게 되는 Global Execution Context의 VO가 가리키고 있는 Global Object를 의미한다. function fooName() {} 와 같이 선언된 함수들은 기본적인 함수 호출에 해당하는데, 이는 일반적인 전역 스코프에 선언된 함수 뿐만 아니라 내부 함수, 콜백 함수로 전달된 함수 호출도 이에 해당한다. 아래 예시를 보자.function test() { console.log(this); // 전역 객체}=&gt; 전역 스코프에서 선언된 함수 호출이므로 전역 객체를 가리킨다.const obj = { name: \"gihan\", foo: function () { console.log(this); // obj 객체 function inner() { console.log(this); // 전역 객체 } },};=&gt; 이후 설명되는 메서드 호출에서는 자신을 메서드로 갖고 있는 객체를 가리키는데, 메서드 내부에서 호출한 내부 함수의 this 마저도 전역 객체를 가리킨다.setTimeout(function () { console.log(this); // 전역 객체}, 100);=&gt; 콜백 함수 역시 마찬가지로 전역 객체가 바인딩된다.메서드 호출함수가 객체의 프로퍼티로 존재한다면, 이는 메서드라고 불리며 this는 해당 객체를 가리키게 된다.const person = { name: \"gihan\", foo: function () { console.log(this); // person 객체 },};생성자 함수 호출생성자 함수를 알아보기 전에, new 키워드에 대해 알 필요가 있다. 자바와 같은 다른 객체 지향 언어에서 new 키워드는 객체를 동적으로 만들어내는 역할을 수행한다. 자바스크립트에서 new 키워드는, 함수를 생성자 함수로써 동작하도록 하여 함수 호출 시 새로운 객체를 만들어 낸다.const a = test(); // undefinedconst b = new test(); // {}자바스크립트에서 함수는 return value를 명시하지 않을 시 undefined를 리턴한다. 하지만, 생성자 함수로써 new 키워드 이후에 함수 호출 시 해당 함수는 undefined 가 아닌 객체를 리턴하는데, 어떤 객체를 리턴하는지는 생성자 함수 동작 방식의 순서로 알아볼 수 있다.(생성자 함수 호출은 함수 호출에 앞서 new 키워드가 필수적으로 동반된다)1. 빈 객체 생성 및 this 바인딩 생성자 함수 호출 이후, 함수 내부에서 빈 객체를 생성하고 this를 해당 객체에 바인딩한다.2. this를 통한 프로퍼티, 메서드 정의 생성자 함수 내부에서 this 키워드를 통해 해당 객체의 프로퍼티와 메서드를 정의할 수 있다.3. 객체 return 프로퍼티와 메서드를 정의한 후, 별도의 return value를 명시하지 않으면 프로퍼티와 메서드를 정의한 해당 객체를 반환한다. 하지만, return value를 명시하면 해당 객체를 반환하지 않는다. 따라서 생성자 함수의 용도로 사용할 함수는 return value를 명시해선 안된다.다음은 생성자 함수를 통한 객체의 생성과 this 바인딩의 예시이다.function Person(name, age) { this.name = name; this.age = age; this.introduce = function () { console.log(this); };}const gihan = new Person(\"gihan\", 23);gihan.introduce();// result : Person {name: 'gihan', age: 23, introduce: ƒ}apply/call/bind 호출this는 함수 호출 패턴에 따라 결정된다고 했는데, 앞서 살펴본 일반 함수, 메서드, 생성자 함수 호출은 자바스크립트에서 자동으로 this를 바인딩 해주는 방식이다. 이번에 살펴볼 apply/call/bind 함수는 개발자가 직접 this를 바인딩하여 사용할 수 있다. 아래는 예시로 사용할 test 함수와 obj 객체이다.function test(param1, param2) { console.log(param1, param2); console.log(this);}const apple = { name: \"apple\",};const banana = { name: \"banana\",};- apply첫 번째 인자로 this를 바인딩 할 객체를, 두 번째 인자로 실제 함수의 인자들을 묶어 만든 배열을 넣어준다. 즉, apply 함수는 호출 시 this를 지정한 객체에 바인딩하여 즉시 호출하는 함수이다.test.apply(apple, [\"a\", \"b\"]); // a b {name: 'apple'}test.apply(banana, [\"a\", \"b\"]); // a b {name: 'banana'}- callapply와 같은 역할을 수행하지만, 실제 함수의 인자를 배열이 아닌 각각 하나의 인자로 넘길 수 있다.test.call(apple, \"a\", \"b\"); // a b {name: 'apple'}test.call(banana, \"a\", \"b\"); // a b {name: 'banana'}- bind인자로 this를 바인딩 할 객체를 넣는다. bind의 리턴 값은 this를 바인딩 시킨 함수 자체를 반환하기 때문에, 바인딩 한 함수를 저장시켜놓고 다시 호출하는 코드가 필요하다. 커링 방식으로도 동작할 수 있다.const appleCall = test.bind(apple);const BananaCall = test.bind(banana);appleCall(\"a\", \"b\"); // a b {name: 'apple'}BananaCall(\"a\", \"b\"); // a b {name: 'banana'}[4] 화살표 함수(Arrow Function)의 this 바인딩일반적으로 this는 함수 호출 패턴에 의해 실행 시간에 동적으로 결정되지만, 화살표 함수의 경우 this 바인딩이 조금 특이하다. 화살표 함수에서는 this를 무조건 상위 정적 스코프에 바인딩한다. 이를 Lexical this라고 한다. 아래 예시를 보자.const obj = { name: \"gihan\", normal: function () { console.log(this); }, arrow: () =&gt; { console.log(this); },};obj.normal(); // {name: 'gihan', normal: ƒ, arrow: ƒ}obj.arrow(); // Window {0: global, 1: global, 2: Window, 3: global, window: Window, …}arrow 메서드는 메서드 호출임에도 불구하고 window 전역 객체가 출력된 것을 확인할 수 있다. 이는 동적으로 this가 결정되는 것이 아니라 항상 상위 스코프에서 this가 정적으로 결정되기 때문이다." }, { "title": "Linux File System", "url": "/posts/Linux-File-System/", "categories": "linux", "tags": "linux, filesystem", "date": "2022-07-02 00:00:00 +0900", "snippet": "컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관, 조직하는 체제를 가리키는 말이라고 한다. 파일 시스템은 운영체제 별로 다를 수 있기 때문에, 여러가지 종류가 존재한다. 이번 글은 리눅스에서 사용되는 파일 시스템인 EXT에 대해 설명하고자 한다.Blocks디스크는 고정된 크기의 block으로 나누어진다. 일반적으로 1개의 block은 4KB이다.Hard Disk Structure하드디스크의 구조는 아래와 같다. 여러 개의 sector가 보여 cluster를 이루고, sector 한 바퀴는 Track이다. Cylinder는 아래와 같이 여러 개의 원판에 존재하는 Track이다.Flie System AllocationSequential Allocation정보가 연속적으로 저장되어 있는 구조이다. CD, DVD 등이 포함된다.Non-Sequential Allocation정보가 연속적으로 저장되어 있지 않고 흩어져 존재한다. index block, FAT (File Allocate Table) 등이 존재한다.Structure데이터를 하나의 파일로 전체 디스크에 저장하는 것은 매우 비효율적인 방법이다. 그렇기 때문에 여러 개의 파일로 나눠 접근하는 방법이 필요하다. 이를 파일 시스템이라고 하는데, 운영체제마다 서로 다른 파일 시스템을 사용한다.partition하드디스크는 여러 개의 파티션으로 나누어져 있다.cylinder groupcylinder group은 여러 개의 cylinder의 조합으로 구성된다.super block파일 시스템에 대한 정보를 포함하고 있는 block 이다.ex) File System Type, data block 개수, inode 개수, inode table 시작 위치 등 …boot block컴퓨터 부팅 시 필요한 부트스트랩 코드를 저장하고 있다. boot block은 어떤 종류의 파일 시스템이든 무조건 포함하고 있다.1sector = 512 Bytes1cluster = 8 sectors,1cluster = 4KBDirect Block, Indirect Block파일 크기가 block size인 4KB를 넘어갈 때, 연속되는 정보를 어떻게 참조해야할까. EXT 파일 시스템에서는 이를 Indirect Block을 통해 해결하고 있다.block size는 4KB이고, 포인터 값은 4 Bytes를 갖는다. 즉, indirect block 하나 당 1024개의 포인터를 저장할 수 있다.우선 파일의 크기가 4KB를 넘지 않는 파일은 Direct Block을 통해 접근할 수 있다. Direct Block은 데이터 블록의 포인터를 갖고, inode 하나 당 12개의 Direct Block 을 갖기 때문에, 48KB의 크기를 가진다.파일의 크기가 4KB가 넘는 경우, 파일은 Indirect Block을 통해 접근 가능하다.Single Indirect Block은 포인터 하나 당 데이터 블록 포인터 배열을 가진다. 그렇기 때문에 포인터 하나 당 1024 개의 데이터 블록에 접근할 수 있고, 총 1024 _ 1024 _ 4 = 4MB 크기의 파일에 접근할 수 있다.Double Indirect Block은 포인터 하나 당 Single Indirect Block의 포인터를 가진다. 총 1024 _ 1024 _ 1024 * 4 = 4GB 크기의 파일에 접근할 수 있다.Triple Indirect Block은 포인터 하나 당 Double Indirect Block의 포인터를 가지고, 4TB 크기의 파일에 접근할 수 있다.Directory리눅스에서 directory는 파일로 간주된다. 즉, 고유한 inode number를 갖고, inode table entry를 갖는다.directory는 데이터 블록에, 포함된 파일과 디렉토리의 i-node 정보를 담고 있다. 그렇기 때문에, directory 내부에서 접근하려고 할 때 해당 i-node 포인터로 데이터 블록에 접근이 가능하고, directory 일 경우 역시 접근 가능하다." }, { "title": "Docker", "url": "/posts/Docker/", "categories": "docker", "tags": "docker, container, image", "date": "2022-07-01 00:00:00 +0900", "snippet": "Linux의 컨테이너 기술을 활용하여 애플리케이션들을 격리시켜주는 소프트웨어.Docker Installdocker는 linux의 컨테이너 기술을 활용하는 소프트웨어이기 때문에, 리눅스가 아닌 OS 위에서는 동작하지 않는다. Window에서 사용하려고 하면 가상머신이 필요하다.이 작업은 몹시 복잡한데, 이를 docker가 알아서 가상 머신을 만들어주고, 그 위에서 실행될 수 있도록 처리한다. 하지만, 가상 머신 위에서 돌리는 것이기 때문에, 약간의 속도 저하가 발생할 수 있다.Docker Image특정 프로세스를 실행하기 위한 모든 파일과 환경을 갖춘 것으로, 더 이상의 의존성 파일을 컴파일하거나 이것저것 설치할 필요가 없는 상태의 파일.Docker hub 라는 곳에 nginx, apache와 같은 유명한 프로그램들이 Docker Image의 형태로 존재하는데, 이것을 그대로 가져와서(pull) 이미지를 실행시킬 수 있다.docker pull [이미지명]Docker ContainerDocker Image를 실행시킨 상태이다. 격리된 공간에서 프로세스를 동작시킨다. 컨테이너는 중지시켜도 사라지지 않고 메모리에 남는다. rm 명령을 통해 삭제할 수 있다.docker run --name [컨테이너명] [이미지명] # run containerdocker stop [컨테이너명] # stop containerdocker rm [컨테이너명] # remove containerHost가 아닌 Container에 CLI를 이용하고 싶을 때는, 다음 명령을 통해 Container 내부에 명령어를 입력할 수 있다.docker exec -it [컨테이너명] /bin/bashNetwork in ContainerContainer는 독립적인 실행환경이기 때문에, 각자 독립적인 포트와 파일 시스템을 갖고 있다. 외부에서 컨테이너에 접속하려면, Host의 포트와 Container의 포트를 포워딩 하는 작업이 필요하다. 아래와 같이 명령어를 사용하면, Host포트에 Container 포트를 포워딩 할 수 있다.docker run -p [Host포트]:[Container포트] [이미지명]FileSystem in ContainerContainer를 삭제하면, 내부에 존재하는 모든 파일이 삭제된다. 그렇기 때문에, Container 내부에서 파일을 수정하면, 수정한 내용이 모두 삭제되는 위험한 상황이 일어날 수 있다. 그렇기 때문에, Host의 파일 시스템과 동기화할 수 있는 방법이 존재한다. 다음 명령을 통해 Host와 Container 간 동기화가 가능하다.docker run -v [Host경로]:[Container경로] [이미지명]Make Docker Imagecommit, build 명령을 통해 도커 이미지를 생성할 수 있다. commit: 현재 실행 중인 컨테이너의 스냅샷을 통해 image를 만들어냄.docker commit [컨테이너명] [새이미지명] build: Dockerfile을 통해 [경로] 안에 존재하는 Dockerfile을 가지고 이미지를 생성함.docker build -t [새이미지명] [경로]Dockerfilebuild 명령은 Dockerfile을 통해 이미지를 생성한다. FROM: 베이스 이미지 RUN: 빌드 시점에 명령어를 실행시킴. RUN을 수행할 때마다 Layer가 생성되기 때문에, &amp;&amp;를 이용하여 한번에 명령하는 것이 효율적. (이미지에 반영됨) install 명령 시 yes/no 확인 창이 나오게 되면 Dockerfile은 정상적으로 작동하지 않음. 그렇기 때문에 install -y 옵션을 사용해야함. WORKDIR: 경로가 존재하면 해당 경로로 이동하고, 경로가 존재하지 않으면 경로를 생성한 뒤에 이동한다. 이후 실행되는 명령어는 모두 WORKDIR 경로에서 실행된다. COPY: 배열 형식으로 Host의 파일을 Container로 복사할 수 있다. [ Host file, Container path ] CMD: 컨테이너를 생성, 실행할 때 실행할 명령어 (컨테이너에 반영됨) docker run으로 컨테이너를 생성하거나, docker start로 정지된 컨테이너를 시작할 때 실행됨. " }, { "title": "AWS EC2", "url": "/posts/AWS-EC2/", "categories": "AWS", "tags": "aws, cloud, EC2, instance", "date": "2022-06-30 00:00:00 +0900", "snippet": "Elastic Computing Cloud로, AWS에서 제공하는 클라우드 컴퓨팅 서비스이다. 즉, AWS로부터 한 대의 컴퓨터를 임대하는 것. AWS가 제공하는 URL을 통해 EC2에 접근이 가능하다.EC2 특징 사용한만큼 초 단위로 요금이 부과된다. 전 세계 어디든지 빠르게 인스턴스를 생성하고 서비스 운영이 가능하다. ELB, Auto Scaling, S3등 다양한 서비스와 연동이 가능하다. 다양한 os를 지원해준다.AZ (Avaliable Zone)EC2와 주요 구성요소들은 AZ 기반. 고가용성을 위해서는 MultiAZ를 이용하여 가용성을 확보해야한다. Multi AZ둘 이상의 AZ를 활용해서 서비스를 구축하는 것. 주로 ELB (Elastic Load Balancer)를 이용해서 서버를 연결해서 사용함.EC2 관련 서비스들 EC2: 서버, CPU EBS (Elastic Block Storage): EC2의 블록 저장장치. SSD, AZ 서비스 VPC (Virtual Private Cloud): EC2가 연결되는 사설 네트워크 망. 리전 기반. Subnet: VPC의 하위망. AZ 서비스로 EC2는 subnet에 위치. ENI (Elastic Network Interface): 가상 네트워크 인터페이스. 랜카드, AZ 서비스 Security Group: EC2의 방화벽, 포트 접근 제어EBS SnapshotEC2의 블록 저장장치인 EBS의 스냅샷을 생성할 수 있다. EBS Snapshot은 리전 서비스이므로 하나의 AZ에서 다른 AZ로 이동시키려할 때 스냅샷을 통해 데이터를 다른 AZ로 이동시킬 수 있다.AMI 생성EC2 는 AZ 서비스이기 때문에, 하나의 AZ에서 다른 AZ로 옮기는 것이 불가능하다. 하지만, AMI는 리전 서비스이기 때문에 AMI를 이용해서 EC2를 다른 AZ로 옮기는 것이 가능해진다.현재 사용중인 EC2 인스턴스를 이용하여 AMI 생성하고, 생성된 AMI를 통해 언제든지 인스턴스를 생성할 수 있다. AMI 생성 시, EBS Snapshot은 필수적으로 함께 생성되는데, AMI를 삭제할 때 함께 삭제해주어야 한다.EC2 meta datacurl 커맨드를 이용하여 정해진 주소로 요청을 보내면, 현재 EC2의 메타데이터를 확인할 수 있다. 아래와 같이 명령어를 사용한다.curl -w '\\n' http://169.254.169.254/latest/meta-data/[메타데이터명]http://169.254.169.254/latest/meta-data/ 주소로 요청을 보내면, 아래와 같은 메타데이터 제목이 터미널에 출력된다.ami-idami-launch-indexami-manifest-pathblock-device-mapping/events/hibernation/hostnameiam/identity-credentials/instance-actioninstance-idinstance-life-cycleinstance-typelocal-hostnamelocal-ipv4macmetrics/network/placement/profilepublic-hostnamepublic-ipv4public-keys/reservation-idsecurity-groupsservices/메타데이터를 통해 EC2 내부에서 스크립트 작업을 수행할 수 있다.EC2 RoleAWS EC2를 사용할 때, AWS의 다른 서비스들과 함께 사용하는 경우가 자주 있다. EC2에서 다른 서비스에 접근하기 위해서는 역시 권한이 필요한데, 임시로 접근 권한을 설정해줄 수 있는 Role이 그 역할을 수행할 수 있다.이전에 Role을 생성할 때는 개체 선택 시 “다른 AWS 계정”을 선택했었는데, EC2 Role을 생성하기 위해서는 개체 선택 시 “AWS 서비스” 를 선택해준다.S3에 대한 접근 권한을 허용하려면 S3FullAccess 정책을 선택해준다.EC2 요금 인스턴스가 실행될 때부터 과금이 시작된다. EC2 요금, EBS 요금, 네트워크 요금이 과금된다. 인스턴스 정지시, EC2 요금은 부과되지 않지만, EBS 요금은 여전히 부과된다. 인스턴스 종료시, EC2와 EBS 모두 사라지며 요금이 부과되지 않는다." }, { "title": "AWS VPC", "url": "/posts/AWS-VPC/", "categories": "AWS", "tags": "aws, cloud, VPC, network", "date": "2022-06-29 00:00:00 +0900", "snippet": "Amazon Virtual Private Cloud로, AWS의 가상 사설 네트워크이다. EC2의 네트워크 계층을 담당한다. S3, EC2등의 많은 AWS 서비스들이 VPC를 통해 네트워크에 연결되어 제공된다. 리전 서비스로써, 리전 내에 존재하는 AZ끼리 공유한다.VPC 내부에는 서브넷이 존재하는 데, 이는 VPC를 더 작은 범위의 네트워크로 나눈 것이고 AZ 서비스이다. 따라서 같은 리전 내부에 존재하는 AZ끼리 공유되지 않는다. EC2 인스턴스는 AZ 서비스이기 때문에 VPC에 직접 연결되지 못하고 반드시 서브넷에 연결된다.CIDR 표기법IP Address/Prefix 형식으로 IP의 범위를 간단하게 표기하는 표기법이다. Prefix는 IP Address의 네트워크 영역과 호스트 영역을 구분하기 위해 사용된다.예를 들어, 192.168.1.1/24 라는 IP Address가 존재한다고 했을 때, Prefix는 24이기 때문에 상위 24비트까지 네트워크 영역이고, 나머지 하위 8비트가 호스트 영역이 된다. 192.168.1.0 라는 네트워크에 2^8개 만큼의 호스트를 보유할 수 있는 네트워크이다.Prefix가 무조건 8의 배수일 필요는 없고, 0과 32사이의 어떤 값도 Prefix가 될 수 있다.VPC 생성AWS VPC의 Prefix는 16~28까지의 범위를 가질 수 있다. VPC를 생성하면 기본적으로 라우팅 테이블이 하나 생성된다.서브넷 생성서브넷은 VPC에 포함되는 영역이기 때문에 역시 Prefix는 16~28까지의 범위를 가질 수 있다. 또한 AZ 서비스이기 때문에 AZ를 선택하고, IP Address 범위를 VPC의 호스트 영역에서 선택할 수 있다.서브넷은 반드시 라우팅 테이블과 연결되어야 하고, 초기에는 VPC의 기본 라우팅 테이블이 지정된다.Internet Gateway (IGW)VPC는 Virtual Private Cloud 이기 때문에, 인터넷 게이트웨이를 VPC에 연결하지 않으면, 인터넷을 이용할 수 없다. 그렇기 때문에, VPC 내부에서 인터넷을 이용하기 위해서는 반드시 인터넷 게이트웨이를 생성하여 VPC에 연결해야한다.Public Subnet인터넷 게이트웨이 규칙이 있는 서브넷을 Public Subnet이라고 한다. 서브넷이 라우팅 테이블과 연결되어 인터넷 세상에 열려 있고, 주로 웹 서버, Bastion Server 등이 존재한다.Public Subnet은 IGW를 통한 인터넷과 직접적인 연결이 되어있기 때문에 Private Subnet이 보안에 더 유리하다.(Bastion Server: 내부 네트워크를 겨냥한 공격에 대해 방어하기 위한 일종의 Proxy)Private Subnet인터넷 게이트웨이와 연결이 되어있지 않은 서브넷이다. 주로 데이터베이스와 같이 중요한 정보를 담고 있거나 보안이 중요한 작업을 수행하는 것들이 존재한다.일반적으로 22번 포트를 통해 ssh 접속을 하는 것과 같이 외부에서 직접적인 접속이 불가능한데, 이로 인해 발생하는 문제가 존재한다. 데이터베이스를 해당 서버에서 실행하기위해 소프트웨어를 설치하거나 업데이트 하는 것이 필요한데, Private 이기 때문에 외부에서 접속이 불가능하다.이를 해결하는 방법은 AWS에서 제공하는 NAT 서비스를 이용하거나, NAT 인스턴스를 생성해서 해결할 수 있다.Private Subnet에 접속하기Private Instance에 접속할 때, ssh를 통해 바로 접속이 불가능하다. Private Instance는 라우팅 테이블에 인터넷 게이트웨이와 연결이 되어있지 않기 때문인데, 그렇기 때문에 Public Instance로 우회하여 접근해야한다. ssh를 통해 Public Instance 접속 → Public Instance에서 ssh를 통해 Private Instance 접속하지만, Private Instance에 접속할 때 역시 Public Instance에 접속하는 것과 마찬가지로 key 가 필요하다. Private Instance로 접속하기 위해선 Public Instance에서 ssh 접속을 해야하고, 그렇게 되면 key 파일이 Public Instance에 파일로 존재해야한다. 이렇게 되면 key가 인터넷과 연결된 곳에 공개되기 때문에, private subnet을 이용하는 이유가 없어진다.해결책은 key forwarding 을 하는 것이다. ssh agent를 통해 key를 등록해놓음으로써, Public Instance에 파일 형태로 존재하는 것을 막을 수 있다. 아래 명령들을 통해 ssh agent에 forwarding 할 key를 등록할 수 있다. key 등록ssh-add -K [key파일명] key 확인ssh-add -L key 연결ssh -A -i [key파일명] [user명]@[PrivateInstanceIP]NAT (Network Address Translation)내부 네트워크에 존재하는 호스트들의 IP를 숨김으로써 외부에서 호스트들에게 접근하지 못하도록 막을 수 있다. 또한, 부족한 IP주소를 절약하여 사용할 수 있다.위에서 Private Subnet에서 NAT인스턴스를 사용하여 인터넷에 접속한 것도 모두 외부에서 내부 호스트(Private Instance)에 접속하는 것을 막기 위함이다. 호스트에서 요청을 보내면 NAT 게이트웨이는 호스트의 Private IP를 게이트웨이가 가지고 있는 Public IP로 변경한다. 요청에 대한 응답을 받을 때, 서비스를 제공한 서버는 호스트의 실제 IP를 알지 못하기 때문에 게이트웨이로 응답을 보내고, 게이트웨이는 해당 IP와 일치하는 호스트 Private IP로 응답을 우회해준다.그렇기 때문에, 외부에서는 내부 호스트의 Private IP를 알지못하고 게이트웨이의 주소만 알 수 있으므로 직접적인 접근이 불가능한 것이다." }, { "title": "AWS S3", "url": "/posts/AWS-S3/", "categories": "AWS", "tags": "aws, cloud, s3, bucket", "date": "2022-06-28 00:00:00 +0900", "snippet": "Amazon Simple Storage Service 의 약자로, SSS를 줄여서 S3라고 함. AWS의 대표적인 서비스로, 객체 스토리지의 역할을 수행한다. S3는 다음과 같은 역할을 수행한다. 파일 업로드, 다운로드, 검색 무제한 용량 (돈이 무제한으로 필요함….!) 다양한 인증/권한 부여 제공S3 용어 bucket: 오브젝트(파일)를 저장하기 위한 컨테이너 버킷명은 전 세계 유일하게 지정해야한다. object: 버킷은 오브젝트 저장소로, 오브젝트 = 파일이다. S3 버킷의 모든 오브젝트들은 고유한 URL이 존재한다. key: 버킷안의 오브젝트를 식별하는데 사용 (Prefix + filename) version: 버저닝을 활성화하면, 파일의 버전을 저장할 수 있다. ex) https://honux-inf.s3.amazonaws.com/2021-1/avartar.png?version= 과 같이 쿼리 스트링으로 버전을 추가할 수 있다. 파일을 수정하면, 수정 이후의 파일만 저장하는 것이 아니라 이전 내용도 모두 저장하므로, 비용에 주의해야한다 ! 파일의 라이프사이클 관리가 불편해진다. ACL: Access Control List로, 각 오브젝트마다 권한을 설정할 수 있다. 주로 간단한 제어에 사용된다. Bucket Policy: IAM Policy와 유사한 문법으로, ACL보다 복잡하고 세부적으로 권한 설정이 가능하다.S3 특징 리전 기반 서비스로 데이터 센터가 분산되어 있다. 그렇기 때문에 굉장히 안정적임 ! CDN과 연동 가능함 static web page 기능을 지원한다. 버저닝 (Versioning) 기능을 사용할 수 있다. 이름이 같은 파일을 여러 번 S3에 저장할 시, 저장될 때마다 버전을 유지할 수 있다. 다양한 요금 옵션으로 비용 절감이 가능하다 !S3 사용 예시 클라우드 저장소 (구글 드라이브처럼 사용 가능) 서비스의 대용량 파일 저장소 - 이미지, 동영상, 빅데이터 등 ex) 넷플릭스 같은 서비스를 만든다고 했을 때 영화들을 S3에 저장해두고 사용할 수 있음 ! 서비스 로그 저장 및 분석 서비스의 로그를 EC2 서버에 저장해두는 것은 안티 패턴임. EC2의 SSD(EBS)에 저장하는 것보다, S3에 파일을 저장하는 것이 훨씬 저렴함. EBS보다 S3가 훨씬 더 안정적임 S3에 저장해두고 사용하도록 하자 ! 서비스 사용자의 데이터 업로드 서버 AWS 아데나를 이용하여 빅데이터 업로드 및 분석이 가능함. SQL 쿼리같은 쿼리문을 날려서 빅데이터 분석이 가능함. S3 권한 제어ACL과 Bucket Policy를 이용하여 버킷의 권한을 제어할 수 있다. 또한 IAM 사용자에게 버킷 접근 권한을 주어 제어할수도 있다.PresignedURL: URL을 이용하여 임시 권한을 부여하는 기능으로, 매우 유용하다 !기본적으로 버킷의 파일들을 모두 private으로, 파일을 식별하는 URL로 접속하면 파일을 확인할 수 없다. 하지만, 권한을 public으로 변경시켜 공개적으로 사용이 가능하다.ACLACL은 버킷 내에 존재하는 파일의 접근 권한을 파일 별로 설정할 수 있다. 리눅스와 비슷하게 파일의 접근 권한을 [객체 소유자, 모든 사람, 인증된 사용자 그룹] 으로 분리하여 권한을 부여할 수 있다.폴더의 ACL을 수정하여 폴더 하위에 존재하는 파일들 모두 public으로 변경하는 것은 불가능하다. 왜냐하면, 폴더 는 ACL 설정이 불가능하기 때문.Bucket PolicyS3에 등록되는 파일들은 기본적으로 파일 소유자를 제외한 나머지 사용자는 접근이 불가능하기 때문에, 권한을 변경하려면 파일을 등록할 때마다 ACL을 편집해주어야 하는 불편함이 있다.이럴 땐, Bucket Policy를 추가하여 해당 폴더 하위에 존재하는 파일들의 접근을 Policy를 통해 허용할 수 있다.Storage ClassS3는 용도에 맞게 다양한 타입의 Storage Class를 제공한다.Standard, Standard-IA, One Zone-IA, Glacier등이 있다.class에 따라 저장 방식도 약간 다르고, 요금에도 차이가 존재한다.Life Cycle파일의 Life Cycle을 지정할 수 있다. 오래 지난 파일은 폐기시키는 등의 작업을 수행할 수 있고, 일정 시간이 지나면 다른 Storage Class 로 변경되는 작업도 수행할 수 있다.Eventual Consistency분산 시스템에서는 CAP 이론에 의해서 일관성(Consistency), 가용성(Availability), 분할 내구성(Partition Tolerance) 3가지 중 2가지만 충족할 수 있음.가용성을 포기하면, 분산되어있는 모든 시스템에 변경이 반영될 때까지 클라이언트는 해당 데이터에 접근 불가능.일관성을 포기하면, 모든 시스템 중 데이터의 변경이 이루어지지 않은 시스템을 참조했을 때, 클라이언트는 변경 이전의 데이터를 참조하게 됨.이것을 Eventual Consistency 라고 하는데, Eventual 하게 일관성을 보장한다는 뜻. 즉, 일관성을 보장하지 않는 경우도 존재한다는 뜻.AWS는 원래 Eventual Consistency 였지만, 개선된 후 강력한 쓰기 후 일관성을 제공한다고 한다. (쓰기 후 바로 읽는 것이 가능하다는 것)" }, { "title": "VSCode Extension - 번역 extension 만들기", "url": "/posts/VSCode-Extension-%EB%B2%88%EC%97%AD-Extension-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "VSCode", "tags": "VSCode, Extension, translate", "date": "2022-06-27 00:00:00 +0900", "snippet": "이전 시간에 vscode extension을 사용하는 방법에 대해 알아봤다. 이번 시간에는 파일의 텍스트를 드래그 하고 extension을 실행하면, 해당 문자를 번역 API를 이용하여 infomation message로 출력하는 extension을 만들어보자.필요한 것 extension을 실행하기 위한 방법 정의. 이전 시간에는 Ctrl + Shift + P 를 누르고 Hello World 를 입력하여 extension을 실행시켰음. 이번 시간에는 단축키를 누른다던지 하는 이벤트를 통해 실행시키도록 해보자. cursor로 드래그한 내용을 vscode api로 text를 얻어올 수 있어야 함. 보통 커서로 선택한 부분을 css에서는 selection이라고 표현하는데, 이것과 관련해서 찾아봐야할 것. vscode api로 text를 얻어왔다면, 번역하기위해 외부 Open API를 이용해야할 것. open API를 사용할 수 있도록 설정해야함. vscode api 내부에서 외부 API 요청을 보낼 수 있는 방법을 찾아야 함. 기본적으로 fetch API가 동작할 것 같긴한데 찾아봐야할 것. CORS를 허용하지 않는다면, API를 Proxy 해줄 서버가 필요할 것. express로 간단히 진행하도록 한다.Activation EventsExtension을 실행 (Activate) 하기 위한 Event 이다. 여러가지 vscode에서 제공하는 이벤트들이 존재하는데, 해당 이벤트가 trigger 되면, extension이 활성화된다. 이벤트의 등록은 package.json의 activationEvents 프로퍼티에 등록할 수 있다. onLanguage지정된 언어의 파일을 open 하면 extension이 활성화된다. 언어는 여러가지를 등록할 수 있고, 아래와 같이 package.json에 등록할 수 있다.\"activationEvents\": [ \"onLanguage:json\", \"onLanguage:markdown\", \"onLanguage:typescript\"]⇒ JSON, md, ts 파일을 open 시 자동으로 extension이 활성화 된다. onCommandCtrl + Shift + P 를 입력하고 onCommand에 지정된 명령어를 입력하면 extension이 활성화된다. 이전 시간에 했던 Hello World 입력 시 extension이 활성화되던 코드이다. 아래와 같이 contributes 부분에 commands를 추가하고 commands와 onCommand 핸들러를 연결해주어야 한다.\"activationEvents\": [ \"onCommand:helloworld.helloWorld\"]\"contributes\": { \"commands\": [ { \"command\": \"helloworld.helloWorld\", \"title\": \"Hello World\" } ],},⇒ Hello World 입력 시 extension이 활성화된다. *vscode를 키면 알아서 자동으로 extension이 시작된다. 이번 시간에 사용할 Activation Events 이다.VSCode Window Eventvscode 창에서 발생하는 event 들에 대해 핸들러를 연결해줄 수 있다. Text 드래그 시 해당 Text를 번역해주는 기능이 필요하므로, window에서 텍스트 드래그 이벤트를 찾아봤다. 그와 적절한 이벤트는 아래와 같이 DidChangeTextEditorSelection이다.vscode.window.onDidChangeTextEditorSelection((e) =&gt; { e.textEditor.document.getText();});event 객체에 text를 얻을 수 있는 함수가 존재해서 출력해보았다. 결과는 아래와 같다.문제가 세 가지 존재한다. 문제 1: 드래그 할 때 이벤트가 활성화 되는 것 뿐만 아니라, 텍스트를 입력할 때도 활성화된다. 문제 2: selection된 text가 아닌, 전체 텍스트 내용을 보여준다. 문제 3: 이벤트가 너무 빨리 발생한다.문제 3은 디바운스를 적용하면 되고, 문제 1과 2를 해결해보자. 문제 1,2를 해결한 코드는 다음과 같다.vscode.window.onDidChangeTextEditorSelection((e) =&gt; { if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) { return; } const start = e.selections[0].start; const end = e.selections[0].end; if (start.isEqual(end)) { return; } const text = e.textEditor.document.getText(new vscode.Range(start, end)); vscode.window.showInformationMessage(text);});알고보니 DidChangeTextEditorSelection 이벤트에는 종류가 세 가지 존재했다. 첫째는 Keyboard 로, 키보드 입력 시 발생하고, 둘째는 Mouse 로, 마우스 클릭이나 드래그와 같은 마우스 이벤트 시 발생하고, 셋째는 Command 로, 명령어 입력시 발생하는 이벤트가 존재한다.우리는 selection 시 이벤트가 활성화 되기를 원하기 때문에, event 종류가 Mouse인 이벤트가 아니면 핸들러를 return 하도록 했다.또한, 마우스를 드래그해서 selection 되도록 하는 이벤트가 아닌, 일반적인 마우스 클릭에도 핸들러가 동작했기 때문에, selection의 start 지점과 end 지점이 일치하면 역시 return 하도록 했다.그리고 getText 함수의 인자로 출력할 Text의 범위를 지정해줄 수 있었는데, vscode API의 Range를 인자로 전달하여 해당 기능을 동작하도록 만들 수 있었다. 결과는 아래와 같다.텍스트 입력 시 출력하는 것이 아니고, selection 시 선택한 부분의 Text만 출력되는 것을 확인할 수 있다.번역selection Text도 얻어왔으니 이제 진짜 번역 기능을 만들 차례이다. 번역 API를 이용하여 만들지만, API를 얻어오는 작업은 VSCode Extension 만들기라는 주제에서 벗어나므로 생략하겠다. API는 카카오의 Translate API를 활용하였다.fetchAPI 요청을 위해서 브라우저에서는 fetch API를 이용하여 API 요청 기능을 만든다. VSCode API에서도 시도한 결과, fetch API를 사용하지 못했다. 구글링을 통해 알아낸 결과, node-fetch 라는 라이브러리를 통해 외부 API 요청을 구현할 수 있다고 한다. npm install node-fetch@2 명령을 통해 node-fetch 라이브러리를 추가해주자.code아래와 같이 API 코드를 작성해준다. 물론, 사용하는 API에 따라 API 요청 함수는 다르게 작성될 수 있다. node-fetch 라이브러리를 import하여 fetch 함수를 사용할 수 있도록 만들어주자.import fetch from \"node-fetch\";const translate = async (word: string, src: string, target: string) =&gt; { try { const res = await fetch( `https://dapi.kakao.com/v2/translation/translate?query=${word}&amp;src_lang=${src}&amp;target_lang=${target}`, { headers: { Authorization: `KakaoAK ${API_KEY}`, }, } ); return res.json(); } catch (e) { console.error(e); }};결과selection 시 오른쪽에 번역된 내용이 Infomation Message 로 출력되는 모습이다. 하지만, 드래그 시 이벤트가 연속적으로 빠르게 발생한다. 디바운스를 적용해보자.아래와 같이 디바운스 함수를 작성하여 적용했다. 핸들러가 호출되고 500ms 이내에 다시 한 번 핸들러가 호출된다면, 이전에 등록했던 핸들러를 취소하고 가장 최근에 등록한 핸들러를 실행하도록 한다.let timer: NodeJS.Timeout;const debounce = (callback: Function) =&gt; (...arg: any[]) =&gt; { if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { callback(...arg); }, 500); };export default debounce;디바운스 적용 후에는 아래와 같이 한 번만 출력되는 것을 확인할 수 있다.결론매우 간단한 VSCode Extension을 만들어보았다. 카카오 API는 이미 다른 앱에 적용해놓은 것이 있어서 시간이 많이 걸리지 않아 30분 ~ 1시간 정도 걸려서 만들 수 있었던 것 같다. 영어로 된 주석 코드를 읽는데 이용해볼 수 있을 것 같다." }, { "title": "AWS", "url": "/posts/AWS/", "categories": "AWS", "tags": "aws, cloud", "date": "2022-06-26 00:00:00 +0900", "snippet": "Root Account 를 사용하지 말고, IAM을 이용해서 IAM 사용자를 생성하고 사용해야한다. 또한, Root Account는 MFA(Multi Factor Authenticator) 를 이용해서 이중화 잠금을 거는 것이 안전하다.AWS InfrastructureRegion → AZ(Availability Zones) → Data Center → PoPs 순서로 구성이 됨. 하나의 AZ에 장애가 발생하더라도, 다른 AZ에서는 서비스를 정상적으로 동작시키기 위해 하나의 Region에 여러 AZ를 구성함.MFA 설정Google OTP 를 이용하여 MFA를 설정가능하다. (휴대폰을 교체하려면 교체전에 MFA를 무조건 삭제하고 교체해야함 !)AWS의 인증과 권한 부여인증 (Authentication)A라는 사용자가 자신이 A가 맞는지 증명하는 것AWS에서 User가 인증을 담당하고 있다.권한 부여 (Authorization)A라는 사용자가 S 라는 행위를 할 때, A가 S를 해도 되는 권한이 있는지 검사하는 것AWS에서 IAM Policy (정책)가 담당하고 있다.IAM (Identify and Access Management)실질적인 권한은 Root Account 와 동일함. 그럼에도 불구하고 Root Account가 아닌 IAM을 만들어서 사용해야하는 이유는, IAM이 노출되었을 때 Root Account를 이용하여 손쉽게 제어할 수 있기 때문 !IAM PolicyAWS 서비스의 접근 권한을 세부적으로 관리하기 위해 JSON 형식의 문서로 정리해둔 것IAM Group &amp; IAM UserIAM 사용자는 사용자 그룹에 포함될 수 있다. 사용자는 자신만의 정책을 가질 수 있고, 사용자 그룹 역시 정책을 가질 수 있다. 사용자끼리 공통된 정책을 가져야 할 때 사용자 그룹 내부에 사용자를 포함시켜 사용하면 편리하다.IAM User는 Long term credential로, Policy 등록 시 영구적으로 이용가능하다.IAM Policy의 종류 AWS 관리 정책 AWS가 미리 만들어 놓은 정책이고, 사용자는 편집이 불가능하다. 사용자 관리 정책 사용자가 자신이 필요한 권한을 얻을 수 있도록 직접 생성한 정책 기존 정책으로부터 생성 및 수정하거나 아예 새로 생성도 가능하다 GUI 편집기 / JSON 편집기 모두 사용 가능 inline 정책 1회성 정책IAM Policy Example Action: AWS Resource에 어떤 작업을 수행할 권리를 줄 것인지 명시 Resource: EC2, S3와 같은 실제 AWS Service를 명시{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"*\", \"Resource\": \"*\" } ]}ARN (Amazon Resource Name)AWS에서 리소스를 유일하게 식별할 수 있는 구분자. 아래는 ARN 주소 형식이다.arn:partition:service:region:account-id:resource-idarn:partition:service:region:account-type/resource-idarn:partition:service:region:account-type:resource-idarn:aws:iam::123456789012:user/vgihanarn:aws:s3:::my-bucket/folder1/file1⇒ IAM은 계정 서비스로, 고유하기 때문에 region을 명시하지 않아도 됨.⇒ S3는 버킷 서비스로, 버킷명은 고유하기 때문에 region을 명시하지 않아도 됨.IAM RoleIAM Role IAM User 뿐만 아니라 AWS 서비스, 다른 계정 및 AWS 관리 계정까지 리소스의 접근 권한을 부여하기 위해 사용함. Short term credential로, IAM User와 달리 만료 기간이 존재하여 임시 자격 증명이라고도 함. assumeRole API를 통해 사용가능함.IAM Role의 구성 Role ARN: Role을 식별할 수 있는 URL IAM Policy: Role이 어떤 권한을 부여할 수 있는지 명시되어있음 신뢰 관계: 어떤 개체가 IAM Role을 호출할 수 있는지IAM Role 사용 예AdministratorAccess 권한을 갖는 vgihan 계정과, PowerUserAccess 권한을 갖는 jade라는 계정을 생성하고 진행했다. jade 계정은 vgihan 계정과 다르게 IAM 서비스를 이용하지 못한다. 그렇기 때문에 임시 자격 증명으로써 IAM을 사용할 수 있는 권한을 가진 IAM Policy를 Role에 추가하여 사용하고자 한다. 일단 Role을 생성하자 ! Role을 사용할 개체 유형 선택 AWS 서비스, 다른 AWS 계정 등을 선택할 수 있다. 지금은 AWS 계정에 권한을 추가하는 것이기 때문에 다른 AWS 계정을 선택한다. 계정 ID 지정 AWS 계정이 Role을 이용할 것이므로, 어떤 사용자가 Role을 사용할 것인지 계정 ID를 지정한다. 정책 선택 IAM 서비스를 이용할 권한을 줄 것이기 때문에, IAMFullAccess Policy를 Role에 추가해준다.생성 후, 신뢰 관계를 확인해보면 다음과 같다.{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::009579746695:root\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": {} } ]}“AWS”: “arn:aws:iam::009579746695:root” 라고 되어있는데, root 라고 입력 시 해당 계정에 있는 모든 사용자가 이 Role에 접근하여 사용이 가능하다. 하지만, developer 계정인 jade 만 이용하려고 한다면 아래와 같이 AWS Property를 수정해야한다.\"AWS\": \"arn:aws:iam::009579746695:user/jade\"적용 후, 아래와 같이 jade 계정으로 로그인 시 IAM 서비스를 이용하지 못하는 것을 확인할 수 있다.하지만, 다음과 같이 역할 전환을 수행하여 방금 만든 Role로 전환하면,IAM 서비스를 이용가능하다 !" }, { "title": "VSCode Extension 만들기", "url": "/posts/VSCode-extension/", "categories": "VSCode", "tags": "VSCode, Extension, frontend", "date": "2022-06-25 00:00:00 +0900", "snippet": "vscode에 다양하고 신기한 앱들이 많은 걸보고 나도 만들어보고 싶단 생각이 들 찰나, 오픈소스 컨트리뷰톤에 vscode extension 개발을 주제로 하는 팀이 있어서 신청했다. 떨어질지도 모르지만 그냥 재밌을 것 같으니 Hello World 앱부터 따라 만들어본다 !참고 링크Your First Extensioninstallyeoman과 vscode extension generator를 설치한다. vscode extension generator가 실질적인 역할을 수행하는 것 같고, yeoman은 빌드를 도와주는 소프트웨어 인듯하다.npm install -g yo generator-codeInitial Project아래 명령을 실행해서 프로젝트의 기본 틀을 만들어준다. 명령을 실행하면 몇 가지 질문 창이 나오는 데, 다음과 같이 입력해준다.yo code# ? What type of extension do you want to create? New Extension (TypeScript)# ? What's the name of your extension? HelloWorld### Press &lt;Enter&gt; to choose default for all options below #### ? What's the identifier of your extension? helloworld# ? What's the description of your extension? LEAVE BLANK# ? Initialize a git repository? Yes# ? Bundle the source code with webpack? No# ? Which package manager to use? npm# ? Do you want to open the new folder with Visual Studio Code? Open with `code`Debug프로젝트가 존재하는 vscode Window에서 F5 키를 누르면 컴파일과 함께 디버깅 모드로 전환되면서 새로운 Window가 하나 열리게 된다. 해당 Window에서 Ctrl+Shift+P 를 누르면 Command Palette 라고 하는 검색창 비슷하게 Window 상단에 열리는 데, 여기에 Hello World를 입력하면 다음과 같은 결과가 나온다.하단에 ‘Hello World from helloworld!’ 라고 하는 문구를 포함한 작은 박스를 확인할 수 있다 !Develop어떻게 위와 같은 결과가 나온 걸까? 프로젝트로 다시 돌아가보자.박스 내부 문구 수정하기 (vscode API)src/extension.ts 파일 내부에 들어가면, 아래와 같은 코드를 확인할 수 있다.vscode.window.showInformationMessage(\"Hello World from helloworld!\");이 문구를 수정하면, 위 박스에 포함되는 문구가 달라진다.extension 실행 커맨드 수정하기 (Activation Event)또한, Command Palette (Ctrl+Shift+P 누르면 열리는 검색 창)에서 해당 extension을 실행하기 위해 입력하는 커맨드도 수정할 수 있다. package.json에서 contributes &gt; commands &gt; title 을 확인하자.\"activationEvents\": [ \"onCommand:helloworld.helloWorld\"],\"contributes\": {\t\"commands\": [\t\t{\t\t\t\"command\": \"helloworld.helloWorld\",\t\t\t\"title\": \"Hello World\" // 이곳을 수정하면 된다 !\t\t}\t]},이러한 결과가 나오는 과정은 다음과 같다. package.json &gt; activationEvents에 onCommand:helloworld.helloworld 를 추가하여 커맨드 입력 시 작업을 수행하도록 한다.Extension File Structureextension 프로젝트의 구조는 다음과 같다. 실질적인 내용은 src &gt; extension.ts에서 일어나는 것 같고, .vscode 폴더 내부에서는 빌드와 관련된 내용을 config 하는 모양이다.vscode extension 프로젝트의 root에는 반드시 manifest 로써 package.json이 존재해야한다고 한다. manifest란 애플리케이션이 실행되는데 있어서 필수적으로 필요한 파일이라고 한다.├── .vscode│ ├── launch.json // Config for launching and debugging the extension│ └── tasks.json // Config for build task that compiles TypeScript├── .gitignore // Ignore build output and node_modules├── README.md // Readable description of your extension's functionality├── src│ └── extension.ts // Extension source code├── package.json // Extension manifest├── tsconfig.json // TypeScript configurationmanifest의 필드에 대한 자세한 애용은 아래 링크로부터 확인할 수 있다.Extension ManifestEntry File (extension.ts)Entry File에서는 activate, deactivate 두 가지 함수를 export 하고 있다. activate 함수는 package.json에 등록한 이벤트가 발생했을 때 실행되는 것이고, deactivate 함수는 extension이 deactivate 하기 전 실행되는 것으로 clean up 작업을 수행할 수 있다.import * as vscode from \"vscode\"; // vscode API를 제공한다/* 등록한 이벤트 트리거 시 작동 */export function activate(context: vscode.ExtensionContext) { console.log('Congratulations, your extension \"helloworld\" is now active!'); // 이벤트를 등록할 수 있다. // helloworld.helloworld 라는 이벤트에 핸들러를 등록한 것. let disposable = vscode.commands.registerCommand( \"helloworld.helloWorld\", () =&gt; { vscode.window.showInformationMessage(\"Hi I'm vgihan !\"); } ); context.subscriptions.push(disposable);}/* extension deactivate 시 작동 */export function deactivate() {}갖고 놀기extension으로 여러가지 기능을 수행할 수 있을 것이다. 아무거나 사용해보면서 감각을 익히자 !windowshowInformationMessage 함수 말고도, window에서 사용할 수 있는 다른 API들이 많이 존재했다. showWarningMessagevscode.window.showWarningMessage(\"Oops! Warning Message ~ !\");⇒ Warning 메시지 박스를 화면에 나타낸다. showInputBoxvscode.window.showInputBox({ title: \"Hello !\" });⇒ 사용자의 Text Input을 받을 수 있는 창을 상단에 열어준다. showOpenDialogvscode.window.showOpenDialog();⇒ File Open 작업을 수행할 수 있다. createWebviewPanelvscode.window.createWebviewPanel(\"view\", \"hello !\");⇒ 새로운 패널을 열어준다. git graph와 같은 extension이 해당 함수를 통해 사용자에게 그래프 view 를 제공하는 것 같다. createTreeViewvscode.window.createTreeView(\"vgihan\", { treeDataProvider: new TreeDataProvider(),});⇒ vscode.TreeDataProvider 인터페이스를 구현하여 사용자의 커스텀 TreeDataProvider를 정의할 수 있다.⇒ 아래 stackoverflow 페이지의 코드를 실행해보았다.⇒ https://stackoverflow.com/questions/56534723/simple-example-to-implement-vs-code-treedataprovider-with-json-data📣 시간 나는대로 더 작성하겠습니당" }, { "title": "CORS", "url": "/posts/CORS/", "categories": "web", "tags": "web, security, cors", "date": "2022-06-24 00:00:00 +0900", "snippet": "교차 출처 리소스 공유 (CORS) 란, 서로 다른 도메인으로 요청을 보낼 수 있도록 허용하는 시스템이다.만약 서로 다른 도메인으로부터 받는 모든 요청에 대한 제약이 없다면, CSRF나 XSS같은 공격에 취약할 수 있다.CSRF정상적인 사용자의 권한을 탈취하여 공격자가 의도한 행위 (데이터 수정, 삭제, 등록) 등의 행위를 함으로써 웹사이트를 공격하는 방법.예를 들어, 페이스북의 어떤 사용자의 권한을 탈취하여 페이스북 서버로 post요청을 보내게 되면, 해당 사용자의 글목록에 새로운 글이 추가되게 되고, delete 요청을 보내면 글을 삭제할 수 있어 큰 문제가 된다.&lt;form action=\"http://facebook.com/api/content\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"body\" value=\"대충 광고하는 내용\" /&gt; &lt;input type=\"submit\" value=\"Click Me\" /&gt;&lt;/form&gt;위 코드에서 submit 버튼을 클릭하게 되면, facebook 서버로 광고성 글을 body에 담아 post 요청이 보내지고, 페이스북 데이터베이스에 글이 저장되게 된다.그렇기 때문에 허용되지 않은 도메인으로부터 받은 요청을 검증할 필요가 있고, SOP(Same Origin Policy)에 의해 허용되지 않은 도메인은 요청을 보낼 수 없게 된다.Stored XSSCSRF와 비슷하지만, Stored XSS 공격은 아무 웹사이트에 스크립트를 삽입하여 공격대상 서버에 요청을 보내는 방식이다.위 사진에는 alert 함수를 호출하도록 스크립트 코드를 작성하였지만, 공격대상 서버로 request를 보내는 코드를 작성하게 되면 이 역시 권한 없는 사용자가 데이터의 수정, 삭제, 등록이 가능하게 되고, 심각한 문제로 이어질 수 있다.그렇기 때문에 허용되지 않은 도메인으로 부터의 요청을 거부하게 된다면 공격을 어느정도 방어할 수 있다.이러한 문제를 해결하기 위해 SOP(Same Origin Policy)를 적용해야 하지만, 실제로 웹 애플리케이션을 설계하는 데 있어서 문제가 되게 된다.SPA(Single Page Application)을 개발할 때, 보통 SPA 서버와 API 서버를 분리하게 된다. 이 때 SPA 서버와 API 서버의 origin이 달라지게 되는데, 이 역시 위에서 언급한 SOP에 위반되기 때문에 적절한 처리가 필요하다. 다음 두 가지 방법을 알아보자.CORS교차 출처 리소스 공유(Cross-Origin Resource Sharing) 로, 위의 문제를 해결할 수 있다. options 메서드를 이용한 요청을 통해 미리 허용된 origin 인지 검사하고 실제 필요한 요청을 처리하는 방식이다.위 그림을 정리해보면, 요청할 메서드와 헤더 종류, origin 전달 (Client -&gt; Server) 허용 목록에 존재하는 메서드와 헤더 종류, origin 인지 검증 후 허용 목록 전달 (Server -&gt; Client) 실제 요청 작업 처리순서로 작업이 진행된다.Proxy두 번째 방법으로 Proxy가 있다. SOP 정책이 적용되는 것은 브라우저이기 때문에 Server&lt;-&gt;Server 간 request에 대해서는 적용되지 않는다. 그렇기 때문에 Client -&gt; API 서버로 전달되는 요청을 SPA 서버에서 Proxy 함으로써 SOP를 우회할 수 있다.두 가지 방법을 살펴보았는데, 보통 개발 시에 webpackDevServer를 통해 proxy를 사용하여 cors를 처리하고, 빌드 시 서버 측에서 cors 보안 설정을 통해 해결한다고 한다.개인적인 생각으로는 서버측에서 cors 보안 설정이 갖춰지지 않은 경우 테스트가 불가능하기 때문에 개발 시에 proxy를 사용하는 것이 아닌가 하고 추측해본다." }, { "title": "Execution Context", "url": "/posts/Execution-Context/", "categories": "JavaScript", "tags": "JavaScript, execution-context, scope", "date": "2022-06-23 00:00:00 +0900", "snippet": "자바스크립트의 동작 원리를 담고 있는 자바스크립트의 핵심 원리. 실행 가능한 코드가 실행되기 위해 필요한 환경이다.실행 컨텍스트의 생성실행 컨텍스트는 프로그램이 실행될 때, 함수가 호출될 때 생성되며 콜스택이라고 하는 후입선출 구조에 push, pop 되며 실행 가능한 자바스크립트 코드의 실행이 일어난다.전역 실행 컨텍스트프로그램이 실행되면, 전역 실행 컨텍스트가 생성되고 콜스택에 쌓인다. 현재 실행하고 있는 코드인 컨트롤이 전역 실행 컨텍스트로 이동하게 된다.함수 실행 컨텍스트프로그램이 실행되고, 코드가 실행될 때 함수의 호출이 일어나면 콜스택에 함수 실행 컨텍스트가 쌓이고 컨트롤이 함수 실행 컨텍스트로 이동하게 된다.실행 컨텍스트의 구조앞서 실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 자바스크립트의 핵심 원리라고 소개했다. 실행 컨텍스트는 3가지의 객체를 가지고 있는데, Variable Object, Scope Chain, this 가 바로 그 세 가지 객체이다. Variable Object 전역 실행 컨텍스트의 경우, 전역 변수, 전역에서 선언된 함수를 객체화하여 담고 있다. 이를 Global Object 라고 한다. 함수 실행 컨텍스트의 경우, 지역 변수, 함수 내부에서 선언된 함수를 객체화하여 담고 있다. 이를 Activation Object 라고 한다. 컨트롤을 가지고 있는 실행 컨텍스트에서 코드를 순서대로 실행할 때, 변수를 가져오는 데 있어서 해당 실행 컨텍스트의 VO를 참조함으로써 변수를 사용할 수 있다. VO에는 변수 뿐만 아니라 해당 환경에서 선언된 함수도 역시 저장되어 있기 때문에, 내부 함수의 호출이 일어났을 때도 VO를 참조하여 호출할 수 있다. 함수 프로퍼티의 경우, [[Scopes]] 라는 객체를 참조하여 자신이 실행되는 환경의 스코프 체인을 참조할 수 있다. 그렇기 때문에 함수가 종료된 이후에도 [[Scope]] 를 이용하여 환경에 존재하는 함수나 변수를 참조할 수 있는데, 이것이 바로 클로저이다. Scope Chain 실행 컨텍스트의 환경에서 선언된 함수나 변수 뿐만 아니라, 상위 컨텍스트의 함수나 변수를 참조할 수 있도록 Scope Chain을 통해 접근할 수 있도록 한다. Scope Chain은 상위 컨텍스트의 참조를 순서대로 가지고 있기 때문에, 만약 함수나 변수의 참조가 일어나서 VO에서 해당 함수나 변수를 찾으려 했지만 찾지 못했을 때, 스코프 체인을 통해 상위 컨텍스트의 VO를 참조하여 해당 함수나 변수가 존재하는 지 찾는다. 이렇게 전역 컨텍스트의 VO까지 거슬러 올라가서도 찾지 못했을 경우 undefined를 반환하게 된다. this 객체를 가리키고 있는데, 어떤 객체를 가리킬 지는 함수 호출 패턴에 의해 결정된다. 일반 함수일 경우 전역 객체를, 객체의 메서드일 경우 해당 객체를, 생성자 함수일 경우 마지막에 리턴하는 빈 객체를 가리킨다. " }, { "title": "HTTPS", "url": "/posts/HTTPS/", "categories": "network", "tags": "network, https, web", "date": "2022-06-22 00:00:00 +0900", "snippet": "HTTPHypertext Transfer Protocol로, 인터넷에서 데이터를 주고 받기 위한 규약. 개발 시 정해진 HTTP 규약을 통해 통신할 수 있다.HTTPSHTTP over Secure Socket Layer로, SSL 위에서 동작하는 HTTP라는 의미. HTTP는 데이터를 주고 받을 때 평문을 주고 받기 때문에 도청 공격에 매우 취약하고, 올바른 사용자로 위장하여 서버의 리소스를 탈취할 수 있음. 그렇기 때문에 통신 시 Application Layer와 Transport Layer 사이에 존재하는 SSL을 통해 암호화하여 HTTP 통신하는 HTTPS가 나오게 됨.SSL 통신 과정 client hello (client → server) 🙆‍♂️ 무작위 데이터, 가능한 암호화 방식의 리스트 전달 server hello (server → client) 🙆‍♂️ 무작위 데이터, 클라이언트의 가능한 암호화 방식 중 하나를 선택하여 해당 암호화 방식을 전달. 인증서 전달 CA check ✅ 인증서를 전달 받은 클라이언트는 브라우저에 존재하는 CA리스트 중 서버의 CA가 존재하는 지 검사. 존재하지 않다면, 경고 메시지 전달. 존재한다면, 브라우저에 저장된 해당 CA의 공개키를 이용하여 인증서 복호화. 복호화에 성공했다면, CA가 맞는 것 이므로 신뢰할 수 있음. key change 🔑 클라이언트는 서버의 무작위 데이터와 클라이언트의 무작위 데이터를 조합하여 데이터를 교환하기 위한 pre master secret을 생성. pre master secret을 CA의 공개키로 암호화 하여 서버로 전달. SSL 보안HTTPS를 통해 데이터를 주고 받고 세션을 해제하는 데 걸리는 시간은 매우 짧으므로, 대칭키를 탈취당했다고 해도 매우 짧은 시간이기 때문에 대칭키를 바로 폐기할 수 있음.왜 공개키로 암호화 하지 않고 대칭키를 따로 만들까?공개키로 암호화하는 작업은 비용이 많이 들어감. 대칭키를 통해 데이터를 암호화하고, 공개키를 통해 대칭키를 교환하는 방식이 더 효율적." }, { "title": "HTTP", "url": "/posts/HTTP/", "categories": "network", "tags": "network, http, web", "date": "2022-06-21 00:00:00 +0900", "snippet": "HTTP/0.9 TCP/IP 링크를 통해 실행되는 ASCII 프로토콜 GET 요청이 유일한 메서드였음. 요청은 한 줄이 다였다. (GET /index.html) 응답도 body가 전부였음. 요청에 대한 처리가 이루어지면, TCP Connection이 끊어짐.&lt;html&gt; A very simple HTML page&lt;/html&gt;HTTP/1.0 요청과 응답 모두에서 HTTP Header의 개념이 생겼다. 상태 코드 또한 응답에 붙어 전송되어, 요청에 대한 응답의 상태 처리를 할 수 있게 되었다. html 파일 외에 다른 문서를 전송할 수도 있게 되었다. (header의 Content-Type 덕분) 요청에 대한 처리가 이루어지면, TCP Connection이 끊어짐. TCP Connection의 open/close를 위한 flow 제한으로 대역폭이 적게 할당됨. 이는 congestion 문제가 발생할 수 있음.HTTP/1.1 1.0의 문제 중, Connection을 재사용 하지 않는 문제를 개선함. 파이프라이닝을 통해 network latency를 줄이려고 함. 청크 응답을 지원함. 캐시 제어 매커니즘이 도입됨. 동일한 IP 주소에 서로 다른 도메인을 호스팅하는 기능이 추가됨. 처음 요청을 받은 작업이 오래 걸리면, 다음 요청에 대한 응답이 완성됐음에도 불구하고 응답할 수 없다. (HOL Block)HTTP/2.0 HOL Block 문제를 해결하기 위해 멀티플렉싱 스트림을 적용함. 요청과 응답을 여러 개의 스트림으로 분리하여 전달함. ⇒ HOL 해결HTTP/3.0 TCP 프로토콜을 사용함으로써 발생하는 문제점을 해결하고자 노력함. 신뢰성을 보장하는 TCP의 특성상, 중간에 패킷 손실 발생 시 해당 패킷을 다시 전달하고, 제대로 전송될 때까지 연결이 중단된다. HTTP 만을 수정하는 것으로 불가능하다고 여겨, UDP를 이용하게 됨. 스트림을 식별자로 구분하여 패킷 손실 발생 시 해당 스트림만 중단되도록 QUIC 프로토콜을 통해 수정한다.참고 문서HTTP 0.9에서 HTTP 3.0까지http의 역사와 http2의 등장[Network] HTTP 1.0 vs HTTP 1.1" } ]
